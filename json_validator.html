<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Validateur Avro</title>
    <style>
        body { font-family: system-ui, sans-serif; margin: 25px; background: #f1f5f9; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .editor { display: flex; background: #fff; border-radius: 8px; overflow: hidden; border: 1px solid #cbd5e1; height: 500px; }
    .gutter { width: 72px; background: #f8fafc; padding: 12px 8px; border-right: 1px solid #e2e8f0; box-sizing: border-box; color: #64748b; font-family: monospace; font-size: 12px; line-height: 20px; overflow: hidden; text-align: right; }
    .gutterInner { position: relative; }
    .gutter .line { display: flex; justify-content: flex-end; align-items: center; gap:6px; height: 20px; padding-right: 6px; }
    .gutter .line .num { color: #64748b; }
    .gutter .line.marker .num { font-weight: 700; color: #fff; background: #dc2626; padding: 2px 6px; border-radius: 4px; }
    .gutter .line.marker .mark { color: #dc2626; font-weight: 900; margin-left:4px; }
    textarea { width: 100%; height: 100%; font-family: monospace; font-size: 12px; line-height: 20px; padding: 12px; border: none; box-sizing: border-box; resize: none; outline: none; overflow: auto; overflow-x: auto; white-space: pre; }
        .editor.dragover { box-shadow: 0 0 0 3px rgba(37,99,235,0.12) inset; }
        .actions { margin: 20px 0; text-align: center; }
        button { background: #2563eb; color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-weight: bold; }
        #res { padding: 20px; border-radius: 8px; display: none; white-space: pre-wrap; line-height: 1.5; margin-top: 12px; }
        .error { background: #fee2e2; color: #991b1b; border: 1px solid #fecaca; }
        .success { background: #dcfce7; color: #166534; border: 1px solid #bbf7d0; }
        .small { font-size: 0.9rem; color:#475569 }
    </style>
</head>
<body>

    <div style="max-width: 1200px; margin: 0 auto;">
        <h2 style="text-align: center;">üõ† Validateur Avro</h2>
        
        <div class="grid">
            <div>
                <h3>1. Sch√©ma (.avsc)</h3>
                <div class="editor" id="schemaEditor" data-role="schema">
                    <div class="gutter" id="schemaGutter"></div>
                    <textarea id="s" wrap="off" spellcheck="false" placeholder="Collez ou chargez le sch√©ma .avsc ici..."></textarea>
                </div>
                <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
                    <button id="loadSchemaBtn">Charger le sch√©ma</button>
                    <button id="formatSchemaBtn" title="Formatter le sch√©ma">{...}</button>
                    <input id="schemaFile" type="file" accept=".avsc,.json" style="display:none">
                </div>
            </div>
            <div>
                <h3>2. Donn√©es JSON</h3>
                <div class="editor" id="jsonEditor" data-role="json">
                    <div class="gutter" id="jsonGutter"></div>
                    <textarea id="j" wrap="off" spellcheck="false" placeholder="Collez ou chargez le JSON ici..."></textarea>
                </div>
                <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
                    <button id="loadJsonBtn">Charger le JSON</button>
                    <button id="formatJsonBtn" title="Formatter le JSON">{...}</button>
                    <input id="jsonFile" type="file" accept=".json,.txt" style="display:none">
                </div>
            </div>
        </div>

        <div class="actions">
            <button id="btn">V√©rifier</button>
        </div>

        <div id="res"></div>
    </div>

<script type="module">
    import avro from 'https://esm.sh/avsc@5.7.9';

    // Elements
    const sEl = document.getElementById('s');
    const jEl = document.getElementById('j');
    const resEl = document.getElementById('res');
    const schemaGutter = document.getElementById('schemaGutter');
    const jsonGutter = document.getElementById('jsonGutter');
    const schemaEditor = document.getElementById('schemaEditor');
    const jsonEditor = document.getElementById('jsonEditor');

    const LS_SCHEMA = 'avro_schema';
    const LS_JSON = 'avro_json';

    // Helpers
    function escapeRegExp(s) {
        return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function updateGutter(textarea, gutter, errorLines = new Set()) {
        const lines = textarea.value.split('\n').length;
        let out = '<div class="gutterInner">';
        for (let i = 1; i <= lines; i++) {
            const isErr = errorLines.has(i);
            const cls = isErr ? 'line marker' : 'line';
            const mark = isErr ? '<span class="mark">‚ùå</span>' : '';
            out += `<span class="${cls}"><span class="num">${i}</span>${mark}</span>`;
        }
        out += '</div>';
        gutter.innerHTML = out;
        // translate inner gutter to match textarea scroll (pixel-accurate)
        const inner = gutter.querySelector('.gutterInner');
        if (inner) inner.style.transform = `translateY(-${textarea.scrollTop}px)`;
    }

    function initEditorSync(textarea, gutter, container) {
        textarea.addEventListener('input', () => {
            updateGutter(textarea, gutter);
            // autosave
            if (textarea === sEl) localStorage.setItem(LS_SCHEMA, textarea.value);
            if (textarea === jEl) localStorage.setItem(LS_JSON, textarea.value);
        });
        textarea.addEventListener('scroll', () => {
            // move inner gutter content instead of scrolling the gutter itself
            const inner = gutter.querySelector('.gutterInner');
            if (inner) inner.style.transform = `translateY(-${textarea.scrollTop}px)`;
        });

        // drag & drop support
        ['dragenter', 'dragover'].forEach(ev => {
            container.addEventListener(ev, (e) => { e.preventDefault(); container.classList.add('dragover'); });
        });
        ['dragleave', 'dragend', 'drop'].forEach(ev => {
            container.addEventListener(ev, (e) => { e.preventDefault(); container.classList.remove('dragover'); });
        });
        container.addEventListener('drop', (e) => {
            e.preventDefault();
            const f = e.dataTransfer.files && e.dataTransfer.files[0];
            if (!f) return;
            const reader = new FileReader();
            reader.onload = () => {
                textarea.value = reader.result;
                updateGutter(textarea, gutter);
                if (textarea === sEl) localStorage.setItem(LS_SCHEMA, textarea.value);
                if (textarea === jEl) localStorage.setItem(LS_JSON, textarea.value);
            };
            reader.readAsText(f, 'utf-8');
        });
    }

    // File load buttons
    document.getElementById('loadSchemaBtn').addEventListener('click', () => document.getElementById('schemaFile').click());
    document.getElementById('loadJsonBtn').addEventListener('click', () => document.getElementById('jsonFile').click());

    // Format buttons
    document.getElementById('formatSchemaBtn').addEventListener('click', () => {
        resEl.style.display = 'block'; resEl.className = '';
        try {
            if (!sEl.value.trim()) return;
            const obj = JSON.parse(sEl.value);
            sEl.value = JSON.stringify(obj, null, 2);
            updateGutter(sEl, schemaGutter);
            localStorage.setItem(LS_SCHEMA, sEl.value);
            resEl.className = 'success';
            resEl.textContent = '‚úÖ Sch√©ma format√©.';
        } catch (err) {
            resEl.className = 'error';
            resEl.textContent = '‚ö†Ô∏è Erreur lors du formatage du sch√©ma: ' + err.message;
        }
    });

    document.getElementById('formatJsonBtn').addEventListener('click', () => {
        resEl.style.display = 'block'; resEl.className = '';
        try {
            if (!jEl.value.trim()) return;
            // we preserve the safe-number regex only for validation; here try to parse raw JSON
            const obj = JSON.parse(jEl.value);
            jEl.value = JSON.stringify(obj, null, 2);
            updateGutter(jEl, jsonGutter);
            localStorage.setItem(LS_JSON, jEl.value);
            resEl.className = 'success';
            resEl.textContent = '‚úÖ JSON format√©.';
        } catch (err) {
            resEl.className = 'error';
            resEl.textContent = '‚ö†Ô∏è Erreur lors du formatage du JSON: ' + err.message;
        }
    });

    document.getElementById('schemaFile').addEventListener('change', (e) => {
        const f = e.target.files[0];
        if (!f) return;
        const r = new FileReader();
        r.onload = () => { sEl.value = r.result; updateGutter(sEl, schemaGutter); localStorage.setItem(LS_SCHEMA, sEl.value); };
        r.readAsText(f, 'utf-8');
        e.target.value = '';
    });

    document.getElementById('jsonFile').addEventListener('change', (e) => {
        const f = e.target.files[0];
        if (!f) return;
        const r = new FileReader();
        r.onload = () => { jEl.value = r.result; updateGutter(jEl, jsonGutter); localStorage.setItem(LS_JSON, jEl.value); };
        r.readAsText(f, 'utf-8');
        e.target.value = '';
    });

    // (download/save buttons removed per request)

    // Initialize editors
    initEditorSync(sEl, schemaGutter, schemaEditor);
    initEditorSync(jEl, jsonGutter, jsonEditor);

    // Restore from localStorage
    window.addEventListener('DOMContentLoaded', () => {
        const savedSchema = localStorage.getItem(LS_SCHEMA);
        const savedJson = localStorage.getItem(LS_JSON);
        if (savedSchema) { sEl.value = savedSchema; }
        if (savedJson) { jEl.value = savedJson; }
        updateGutter(sEl, schemaGutter);
        updateGutter(jEl, jsonGutter);
    });

    // Compute error lines by searching the raw textarea text for the path keys and their ancestors.
    // This looks for occurrences of the last key and validates that parent keys appear before it.
    function computeErrorLines(data, errors) {
        const lines = new Set();
        const text = jEl.value || '';

        function nextNonWhite(idx) {
            while (idx < text.length && /\s/.test(text[idx])) idx++;
            return idx;
        }

        function findColonAfter(pos) {
            let i = pos;
            while (i < text.length) {
                if (text[i] === ':') return i;
                i++;
            }
            return -1;
        }

        // find start index of nth array element given arrayStart (position of '[')
        function findArrayElementStart(arrayStart, elementIndex) {
            let i = arrayStart + 1;
            let depth = 0; // depth for nested structures inside elements
            let currentElement = 0;
            // skip initial whitespace
            while (i < text.length) {
                // skip whitespace
                while (i < text.length && /\s/.test(text[i])) i++;
                if (i >= text.length) break;
                if (text[i] === ']') return -1; // empty or ended
                // start of element
                if (currentElement === elementIndex) return i;
                // otherwise skip this element entirely by scanning until comma at depth 0 or closing ]
                depth = 0;
                while (i < text.length) {
                    const ch = text[i];
                    if (ch === '"') {
                        // skip string literal
                        i++;
                        while (i < text.length) {
                            if (text[i] === '\\') { i += 2; continue; }
                            if (text[i] === '"') { i++; break; }
                            i++;
                        }
                        continue;
                    } else if (ch === '{' || ch === '[') {
                        depth++;
                    } else if (ch === '}' || ch === ']') {
                        if (depth === 0) break;
                        depth--;
                    } else if (ch === ',' && depth === 0) {
                        i++; break; // next element
                    }
                    i++;
                }
                currentElement++;
            }
            return -1;
        }

        // Recursive/backtracking attempt: try to match path segments starting from searchPos
        function matchFromIndex(pathArr, idx, searchPos) {
            if (idx >= pathArr.length) return searchPos;
            const seg = String(pathArr[idx]);
            if (/^\d+$/.test(seg)) {
                // numeric index: find array start at or after searchPos
                const bracket = text.indexOf('[', searchPos);
                if (bracket === -1) return -1;
                const elemStart = findArrayElementStart(bracket, parseInt(seg, 10));
                if (elemStart === -1) return -1;
                return matchFromIndex(pathArr, idx + 1, elemStart);
            } else {
                const keyToken = `"${seg}"`;
                let found = text.indexOf(keyToken, searchPos);
                while (found !== -1) {
                    const colon = findColonAfter(found + keyToken.length);
                    if (colon === -1) { found = text.indexOf(keyToken, found + 1); continue; }
                    const vstart = nextNonWhite(colon + 1);
                    const res = matchFromIndex(pathArr, idx + 1, vstart);
                    if (res !== -1) return res;
                    found = text.indexOf(keyToken, found + 1);
                }
                return -1;
            }
        }

        errors.forEach(err => {
            const path = Array.isArray(err.path) ? err.path : (String(err.path).split('.') || []);
            if (!path.length) return;
            // try to match from start of file; matchFromIndex returns position where last element/value starts
            const pos = matchFromIndex(path, 0, 0);
            if (pos !== -1) {
                const ln = text.slice(0, pos).split('\n').length;
                lines.add(ln);
                return;
            }

            // fallback: previous strategies (by key or value)
            const last = String(path[path.length - 1]);
            const keyToken = `"${last}"`;
            const lastIdx = text.lastIndexOf(keyToken);
            if (lastIdx !== -1) {
                const ln = text.slice(0, lastIdx).split('\n').length;
                lines.add(ln);
                return;
            }

            try {
                const valText = JSON.stringify(err.value);
                const vi = text.indexOf(valText);
                if (vi !== -1) {
                    const ln = text.slice(0, vi).split('\n').length;
                    lines.add(ln);
                    return;
                }
            } catch (e) { /* ignore */ }
        });

        return lines;
    }

    // Main validation
    document.getElementById('btn').addEventListener('click', () => {
        resEl.style.display = 'block';
        resEl.className = '';
        resEl.textContent = '';

        const schemaText = sEl.value;
        const dataText = jEl.value;

        try {
            const safeDataText = dataText.replace(/:\s*(-?\d{12,})(\s*[,}\n])/g, ':"$1"$2');
            const data = JSON.parse(safeDataText);

            const type = avro.parse(JSON.parse(schemaText), {
                typeHook: (schema, opts) => {
                    if (schema === 'long' || (schema && schema.type === 'long')) {
                        return new class PermissiveLongType extends avro.types.LongType {
                            _check(val, see, errorHook) {
                                if (typeof val === 'string' && /^-?\d+$/.test(val)) return true;
                                if (typeof val === 'bigint') return true;
                                if (typeof val === 'number' && Number.isInteger(val)) return true;
                                if (errorHook) errorHook(val, this);
                                return false;
                            }
                        }(schema, opts);
                    }
                    return null;
                }
            });

            const errors = [];
            const isValid = type.isValid(data, {
                errorHook: (path, value, type) => {
                    // Keep both machine-friendly and human-friendly info
                    errors.push({ path: path || [], value, typeName: type && type.typeName ? type.typeName : String(type) });
                }
            });

            if (isValid) {
                resEl.className = 'success';
                resEl.innerHTML = "‚úÖ <b>VALIDE !</b>\n\nLe JSON est conforme üéâ";
                updateGutter(jEl, jsonGutter, new Set());
            } else {
                const human = errors.map(e => `${e.path.join('.')} (Attendu: ${e.typeName}, Re√ßu: ${typeof e.value} \"${e.value}\")`);
                resEl.className = 'error';
                resEl.innerHTML = `‚ùå <b>ERREUR DE CONFORMIT√â</b>\n\nChamps invalides :\n- ${human.join('\n- ')}`;

                // Compute line markers and update gutter
                const errorLines = computeErrorLines(data, errors);
                updateGutter(jEl, jsonGutter, errorLines);
            }

        } catch (e) {
            resEl.className = 'error';
            resEl.innerHTML = "‚ö†Ô∏è <b>ERREUR TECHNIQUE</b>\n" + e.message;
            // Attempt to mark a line for JSON parse errors (best-effort)
            try {
                // Look for position info like 'position 123' in message
                const m = /position\s*(\d+)/i.exec(e.message);
                if (m) {
                    const pos = parseInt(m[1], 10);
                    const text = jEl.value;
                    const ln = text.slice(0, pos).split('\n').length;
                    updateGutter(jEl, jsonGutter, new Set([ln]));
                }
            } catch (err) { /* ignore */ }
        }
    });

</script>
</body>
</html>